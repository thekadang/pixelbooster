# 프로젝트: 더카당 픽셀부스터 - 기술 아키텍처 및 보안 계획

이 문서는 '더카당 픽셀부스터'의 백엔드 서버 선정, 장기 확장성 계획, 그리고 핵심 보안 및 어뷰징 방지 전략을 정의합니다.

---

## 1. 서버 아키텍처 (BaaS)

### 1.1. 핵심 원칙

본 프로젝트의 핵심 기능(이미지 변환)은 서버가 아닌 **사용자 컴퓨터(클라이언트/로컬)에서 실행**됩니다. 서버의 역할은 다음과 같이 최소화됩니다.

* 사용자 인증 (회원가입, 로그인)
* 구독 등급 관리 (Free, Basic, Pro 상태 확인)
* 어필리에이트 데이터 관리
* 관리자 대시보드 호스팅

### 1.2. 추천 플랫폼: Supabase (BaaS)

초기 비용 최소화, 개발 속도 극대화, 장기 확장성을 모두 고려하여 **Supabase** (Backend as a Service)를 메인 백엔드 플랫폼으로 선정합니다.

* **선정 이유 (vs AWS/GCP):**
    * **All-in-One:** 인증, 관계형 DB(PostgreSQL), 서버리스 함수(API), 호스팅을 **하나의 완제품**으로 제공합니다. AWS/GCP는 기초 부품(IaaS)이므로 이 모든 것을 직접 개발/설치해야 합니다.
    * **압도적인 개발 속도:** 사용자 인증, DB API 등이 이미 구현되어 있어, 개발자는 앱 핵심 기능에만 집중할 수 있습니다.
    * **초기 비용 $0:** 프로젝트 초기 단계에서는 관대한 무료 플랜으로도 충분히 운영 가능합니다.
    * **관계형 DB:** 어필리에이트 시스템처럼 복잡한 관계(사용자-추천인-수익률)를 구현하는 데 NoSQL(Firebase)보다 PostgreSQL이 훨씬 유리합니다.

---

## 2. 장기 확장성 및 이전 계획 (100만 사용자)

서비스가 성공하여 100만 사용자 규모가 되었을 때의 확장 계획은 다음과 같습니다.

### 2.1. 데이터 이전 (난이도: 하)

* **핵심:** Supabase는 **표준 PostgreSQL**을 사용합니다.
* **전략:** 모든 사용자 정보, 구독 정보, 기기 정보가 담긴 DB를 `pg_dump` (표준 백업) 기능으로 백업합니다.
* **이전:** AWS (RDS for PostgreSQL) 또는 GCP (Cloud SQL for PostgreSQL)에 새 인스턴스를 생성하고, 백업 파일을 그대로 복원(`pg_restore`)합니다.
* **결과:** **데이터 손실이나 구조 변경 없이 100%** 안전하게 이전됩니다.

### 2.2. 로직/코드 이전 (난이도: 중)

데이터는 이전되지만, Supabase가 제공하던 편의 기능 API는 직접 구현해야 합니다.

* **작업:**
    1.  **인증 API 교체:** 앱의 `supabase.auth` 코드를 AWS Cognito 또는 직접 구현한 JWT 인증 API 호출로 변경합니다.
    2.  **DB API 교체:** 앱의 `supabase.from()` 코드를, 새로 구축한 자체 API 서버(예: Node.js + Express)를 호출하는 코드로 변경합니다.
* **현실적 시나리오:** AWS/GCP로의 완전 이전은 막대한 트래픽 비용을 절감하기 위한 '전략적 선택'입니다. 그전까지는 **Supabase 유료 플랜으로 업그레이드**하는 것만으로도(코드 수정 불필요) 100만 사용자까지 충분히 대응 가능합니다.

---

## 3. 보안 계획 (해킹 방지)

### 3.1. Supabase 기본 제공 보안

* **인증:** 비밀번호는 `bcrypt`로 안전하게 해시 암호화되어 저장됩니다.
* **토큰:** 로그인은 안전한 `JWT`(JSON Web Token) 방식으로 처리됩니다.
* **통신:** 모든 API 통신은 `HTTPS (SSL)`로 기본 암호화됩니다.

### 3.2. 필수 구현 보안: RLS (Row Level Security)

* **목표:** 해커가 타인의 구독 정보나 개인정보를 탈취하는 것을 원천 차단합니다.
* **구현:** Supabase의 **Row Level Security** 기능을 활성화해야 합니다.
* **규칙 (예시):** `user_subscription` 테이블에 **"이 테이블의 데이터는, 오직 로그인한 사용자 본인(`auth.uid()`)의 `user_id`와 일치하는 데이터만 보거나 수정할 수 있다"** 라는 정책(Policy)을 DB 자체에 적용합니다.

---

## 4. 어뷰징 방지 (계정 공유 방지)

한 개의 유료 'Pro' 계정을 여러 사용자가 돌려쓰는 행위를 방지합니다.

### 4.1. 핵심 전략: 등급별 기기 등록 수 제한

* **정책 예시:**
    * **Free:** 1대
    * **Basic:** 2대
    * **Pro:** 5대

### 4.2. 구현 아키텍처

1.  **데이터베이스 (Supabase):**
    * `registered_devices` 테이블을 신규 생성합니다.
    * **컬럼:** `id`, `user_id` (사용자 FK), `device_id` (기기 고유값), `device_name` (예: "내 맥북"), `created_at`

2.  **클라이언트 (데스크톱 앱):**
    * 최초 로그인 시, `uuid` 등을 사용해 해당 기기의 고유 식별자(`device_id`)를 생성하고 로컬에 안전하게 저장합니다.

3.  **서버 API (Supabase Edge Function):**
    * 기본 로그인 API 대신, `/login-with-device-check`와 같은 **커스텀 함수(API)**를 개발하여 호출합니다.
    * **로그인 로직:**
        a.  사용자 이메일/비밀번호 인증을 시도합니다. (성공)
        b.  `user_id`로 구독 등급(예: `Pro`, 5대 제한)을 조회합니다.
        c.  `registered_devices` 테이블에서 해당 `user_id`의 기기 수를 `count`합니다.
        d.  **[분기 처리]**
            * **Case 1 (기존 기기):** 요청받은 `device_id`가 이미 테이블에 존재하면 -> **로그인 즉시 허용**.
            * **Case 2 (새 기기 / 한도 이내):** `device_id`가 새롭고, `count`가 5대 미만이면 -> `device_id`를 테이블에 **신규 등록**하고 **로그인 허용**.
            * **Case 3 (새 기기 / 한도 초과):** `device_id`가 새롭고, `count`가 5대 이상이면 -> **로그인 거부** (앱에 "기기 한도를 초과했습니다." 메시지 전송).

4.  **웹 UI (계정 관리 페이지):**
    * 사용자가 웹사이트에서 '내 계정 > 기기 관리' 페이지에 접근할 수 있어야 합니다.
    * 이 페이지에서 본인의 `registered_devices` 목록을 확인하고, 안 쓰는 기기를 '등록 해제'(테이블에서 `delete`)하여 새 기기를 위한 공간을 확보할 수 있습니다.